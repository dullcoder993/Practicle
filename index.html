<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>10 Practical Code Snippets</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #fafafa;
  }
  h1 {
    text-align: center;
    margin-bottom: 30px;
  }
  .snippet {
    background-color: #f4f4f4;
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .title {
    font-weight: bold;
    margin-bottom: 10px;
  }
  pre {
    background-color: #222;
    color: #fff;
    padding: 10px;
    border-radius: 4px;
    overflow-x: auto;
  }
</style>
</head>
<body>

<h1>10 Practical Code Snippets</h1>

<div class="snippet">
  <div class="title"><h1>1. Student Database</h1></div>
  <pre><code>
    
#include iostream //Add angle bracket around header file
#include cstring //Add angle bracket around header file
#include cstdlib //Add angle bracket around header file
#include algorithm //Add angle bracket around header file
#include chrono //Add angle bracket around header file

using namespace std;

struct Student {
    int id;
    char name[50];
    float cgpa;
};

// Function Prototypes
void addStudent(Student* &students, int &size);
void displayStudents(Student* students, int size);
int linearSearch(Student* students, int size, int id);
int binarySearch(Student* students, int size, int id);
void bubbleSortByName(Student* students, int size);
void selectionSortByCGPA(Student* students, int size, bool ascending);

int main() {
    Student* students = (Student*)malloc(0); // Initially empty
    int size = 0, choice;

    do {
        cout << "\n===== Student Database Menu =====\n";
        cout << "1. Add Student\n";
        cout << "2. Display All Students\n";
        cout << "3. Linear Search by ID\n";
        cout << "4. Binary Search by ID (after sorting by ID)\n";
        cout << "5. Sort by Name (Bubble Sort)\n";
        cout << "6. Sort by CGPA (Selection Sort)\n";
        cout << "0. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch(choice) {
            case 1:
                addStudent(students, size);
                break;

            case 2:
                displayStudents(students, size);
                break;

            case 3: {
                int id;
                cout << "Enter ID to search: ";
                cin >> id;

                auto start = chrono::high_resolution_clock::now();
                int index = linearSearch(students, size, id);
                auto end = chrono::high_resolution_clock::now();

                if(index != -1)
                    cout << "Student found: " << students[index].name << " | CGPA: " << students[index].cgpa << "\n";
                else
                    cout << "Student not found!\n";

                cout << "Linear Search Time: "
                     << chrono::duration_cast<chrono::microseconds>(end - start).count() << " microseconds\n";
                break;
            }

            case 4: {
                // Sort by ID for Binary Search
                sort(students, students + size, [](Student a, Student b){ return a.id < b.id; });

                int id;
                cout << "Enter ID to search: ";
                cin >> id;

                auto start = chrono::high_resolution_clock::now();
                int index = binarySearch(students, size, id);
                auto end = chrono::high_resolution_clock::now();

                if(index != -1)
                    cout << "Student found: " << students[index].name << " | CGPA: " << students[index].cgpa << "\n";
                else
                    cout << "Student not found!\n";

                cout << "Binary Search Time: "
                     << chrono::duration_cast<chrono::microseconds>(end - start).count() << " microseconds\n";
                break;
            }

            case 5:
                bubbleSortByName(students, size);
                cout << "Sorted by Name (Alphabetically)\n";
                break;

            case 6: {
                int order;
                cout << "Sort CGPA in: 1. Ascending  2. Descending: ";
                cin >> order;
                selectionSortByCGPA(students, size, order == 1);
                cout << "Sorted by CGPA\n";
                break;
            }

            case 0:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice! Try again.\n";
        }

    } while(choice != 0);

    free(students);
    return 0;
}

// Function Definitions

void addStudent(Student* &students, int &size) {
    size++;
    students = (Student*)realloc(students, size * sizeof(Student));

    cout << "Enter Student ID: ";
    cin >> students[size - 1].id;
    cin.ignore();
    cout << "Enter Name: ";
    cin.getline(students[size - 1].name, 50);
    cout << "Enter CGPA: ";
    cin >> students[size - 1].cgpa;

    cout << "Student added successfully!\n";
}

void displayStudents(Student* students, int size) {
    if(size == 0) {
        cout << "No students in database.\n";
        return;
    }
    cout << "\nID\tName\t\tCGPA\n";
    for(int i = 0; i < size; i++) {
        cout << students[i].id << "\t" << students[i].name << "\t\t" << students[i].cgpa << "\n";
    }
}

int linearSearch(Student* students, int size, int id) {
    for(int i = 0; i < size; i++) {
        if(students[i].id == id)
            return i;
    }
    return -1;
}

int binarySearch(Student* students, int size, int id) {
    int low = 0, high = size - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if(students[mid].id == id)
            return mid;
        else if(students[mid].id < id)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}

void bubbleSortByName(Student* students, int size) {
    for(int i = 0; i < size - 1; i++) {
        for(int j = 0; j < size - i - 1; j++) {
            if(strcmp(students[j].name, students[j + 1].name) > 0) {
                swap(students[j], students[j + 1]);
            }
        }
    }
}

void selectionSortByCGPA(Student* students, int size, bool ascending) {
    for(int i = 0; i < size - 1; i++) {
        int index = i;
        for(int j = i + 1; j < size; j++) {
            if(ascending ? (students[j].cgpa < students[index].cgpa) : (students[j].cgpa > students[index].cgpa)) {
                index = j;
            }
        }
        swap(students[i], students[index]);
    }
}



  </code></pre>
</div>

<div class="snippet">
  <div class="title"> <h1>2. Prefix to Infix</h1></div>
  <pre><code>
    #include iostream //Add angle bracket around header file
#include cctype //Add angle bracket around header file
#include algorithm //Add angle bracket around header file
using namespace std;

// Node structure
struct Node {
    char data;
    Node* next;
};

// Stack ADT using singly linked list
class Stack {
    Node* top;

public:
    Stack() {
        top = nullptr;
    }

    void push(char val) {
        Node* temp = new Node;
        temp->data = val;
        temp->next = top;
        top = temp;
    }

    char pop() {
        if (isEmpty()) {
            return '\0';
        }
        Node* temp = top;
        char popped = top->data;
        top = top->next;
        delete temp;
        return popped;
    }

    char peek() {
        if (!isEmpty())
            return top->data;
        return '\0';
    }

    bool isEmpty() {
        return top == nullptr;
    }

    ~Stack() {
        while (!isEmpty())
            pop();
    }
};

// Operator precedence
int precedence(char op) {
    if (op == '^') return 3;
    if (op == '*' || op == '/') return 2;
    if (op == '+' || op == '-') return 1;
    return 0;
}

// Check if character is operator
bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
}

// Infix → Postfix conversion
string infixToPostfix(string infix) {
    Stack s;
    string postfix = "";

    for (char& ch : infix) {
        if (isalnum(ch)) {
            postfix += ch;
        }
        else if (ch == '(') {
            s.push(ch);
        }
        else if (ch == ')') {
            while (!s.isEmpty() && s.peek() != '(') {
                postfix += s.pop();
            }
            s.pop(); // remove '('
        }
        else if (isOperator(ch)) {
            while (!s.isEmpty() && precedence(ch) <= precedence(s.peek())) {
                postfix += s.pop();
            }
            s.push(ch);
        }
    }

    while (!s.isEmpty()) {
        postfix += s.pop();
    }

    return postfix;
}

// Infix → Prefix conversion
string infixToPrefix(string infix) {
    // Step 1: Reverse infix and swap ( and )
    reverse(infix.begin(), infix.end());
    for (char& ch : infix) {
        if (ch == '(') ch = ')';
        else if (ch == ')') ch = '(';
    }

    // Step 2: Convert to postfix
    string postfix = infixToPostfix(infix);

    // Step 3: Reverse postfix → prefix
    reverse(postfix.begin(), postfix.end());
    return postfix;
}

// MAIN FUNCTION
int main() {
    string infix;

    cout << "Enter infix expression: ";
    cin >> infix;

    string postfix = infixToPostfix(infix);
    string prefix = infixToPrefix(infix);

    cout << "\nPostfix: " << postfix;
    cout << "\nPrefix : " << prefix;

    return 0;
}



</code></pre>
</div>

<div class="snippet">
  <div class="title"><h1>3. Circular Queue</h1></div>
  <pre><code>
    #include iostream //Add angle bracket around header file
using namespace std;

#define MAX 5  // Fixed size of the queue

class CircularQueue {
    int queue[MAX];
    int front, rear;

public:
    CircularQueue() {
        front = -1;
        rear = -1;
    }

    bool isFull() {
        return (front == (rear + 1) % MAX);
    }

    bool isEmpty() {
        return (front == -1);
    }

    void enqueue(int value) {
        if (isFull()) {
            cout << "Queue is Full! Cannot insert " << value << endl;
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX;
        }
        queue[rear] = value;
        cout << "Inserted: " << value << endl;
    }

    void dequeue() {
        if (isEmpty()) {
            cout << "Queue is Empty! Cannot delete.\n";
            return;
        }
        cout << "Deleted: " << queue[front] << endl;
        if (front == rear) {  // Only one element
            front = rear = -1;
        } else {
            front = (front + 1) % MAX;
        }
    }

    void display() {
        if (isEmpty()) {
            cout << "Queue is Empty!\n";
            return;
        }

        cout << "Queue contents: ";
        int i = front;
        while (true) {
            cout << queue[i] << " ";
            if (i == rear)
                break;
            i = (i + 1) % MAX;
        }
        cout << endl;
    }
};

// Main menu-driven function
int main() {
    CircularQueue cq;
    int choice, value;

    do {
        cout << "\n--- Circular Queue Menu ---\n";
        cout << "1. Enqueue (Insert)\n";
        cout << "2. Dequeue (Delete)\n";
        cout << "3. Display\n";
        cout << "4. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value to insert: ";
            cin >> value;
            cq.enqueue(value);
            break;
        case 2:
            cq.dequeue();
            break;
        case 3:
            cq.display();
            break;
        case 4:
            cout << "Exiting...\n";
            break;
        default:
            cout << "Invalid choice!\n";
        }
    } while (choice != 4);

    return 0;
}
  </code></pre>
</div>

<div class="snippet">
  <div class="title"><h1>4. BST</h1></div>
  <pre><code>
    class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    # a) Insert (with handling duplicates)
    def insert(self, root, data):
        if root is None:
            return Node(data)
        elif data < root.data:
            root.left = self.insert(root.left, data)
        elif data > root.data:
            root.right = self.insert(root.right, data)
        else:
            print(f"Duplicate entry '{data}' not allowed.")
        return root

    # b) Delete a node
    def delete(self, root, key):
        if root is None:
            return root
        if key < root.data:
            root.left = self.delete(root.left, key)
        elif key > root.data:
            root.right = self.delete(root.right, key)
        else:
            # Node with one or no child
            if root.left is None:
                return root.right
            elif root.right is None:
                return root.left
            # Node with two children
            temp = self.find_min(root.right)
            root.data = temp.data
            root.right = self.delete(root.right, temp.data)
        return root

    def find_min(self, node):
        while node.left is not None:
            node = node.left
        return node

    # c) Search
    def search(self, root, key):
        if root is None or root.data == key:
            return root
        if key < root.data:
            return self.search(root.left, key)
        return self.search(root.right, key)

    # d) Display tree (Traversal)
    def inorder(self, root):
        if root:
            self.inorder(root.left)
            print(root.data, end=' ')
            self.inorder(root.right)

    def preorder(self, root):
        if root:
            print(root.data, end=' ')
            self.preorder(root.left)
            self.preorder(root.right)

    def postorder(self, root):
        if root:
            self.postorder(root.left)
            self.postorder(root.right)
            print(root.data, end=' ')

    # e) Depth of tree
    def depth(self, root):
        if root is None:
            return 0
        left_depth = self.depth(root.left)
        right_depth = self.depth(root.right)
        return max(left_depth, right_depth) + 1

    # f) Mirror image
    def mirror(self, root):
        if root:
            root.left, root.right = self.mirror(root.right), self.mirror(root.left)
        return root

    # g) Create a copy
    def copy(self, root):
        if root is None:
            return None
        new_node = Node(root.data)
        new_node.left = self.copy(root.left)
        new_node.right = self.copy(root.right)
        return new_node

    # h) Display all parent nodes with their child nodes
    def display_parents(self, root):
        if root:
            if root.left or root.right:
                print(f"Parent: {root.data}", end=" => ")
                if root.left:
                    print(f"L: {root.left.data}", end=' ')
                if root.right:
                    print(f"R: {root.right.data}", end=' ')
                print()
            self.display_parents(root.left)
            self.display_parents(root.right)

    # i) Display leaf nodes
    def display_leaves(self, root):
        if root:
            if root.left is None and root.right is None:
                print(root.data, end=' ')
            self.display_leaves(root.left)
            self.display_leaves(root.right)

    # j) Display tree level-wise (BFS)
    def level_order(self, root):
        if root is None:
            return
        queue = [root]
        while queue:
            current = queue.pop(0)
            print(current.data, end=' ')
            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

# ---------- DEMO ----------
if __name__ == "__main__":
    tree = BST()
    root = None
    elements = [50, 30, 70, 20, 40, 60, 80, 20]

    for el in elements:
        root = tree.insert(root, el)

    print("Inorder Traversal:")
    tree.inorder(root)
    print("\n\nDepth of tree:", tree.depth(root))

    print("\nLevel Order Traversal:")
    tree.level_order(root)

    print("\n\nMirror Image Inorder Traversal:")
    mirrored = tree.mirror(tree.copy(root))
    tree.inorder(mirrored)

    print("\n\nLeaf Nodes:")
    tree.display_leaves(root)

    print("\n\nParent Nodes with Children:")
    tree.display_parents(root)

    print("\n\nSearching for 40:", "Found" if tree.search(root, 40) else "Not Found")
    print("Searching for 100:", "Found" if tree.search(root, 100) else "Not Found")

    print("\nDeleting 70...")
    root = tree.delete(root, 70)
    print("Inorder After Deletion:")
    tree.inorder(root)
</code></pre>
</div>

<div class="snippet">
  <div class="title"><h1>5. Prims Algorithm</h1></div>
  <pre>
    <code>
       class Graph:
    def __init__(self, vertices):
        self.V = vertices  # number of vertices
        self.graph = []    # to store edges (u, v, w)

    def add_edge(self, u, v, w):
        self.graph.append([u, v, w])

    # Find function (for disjoint set)
    def find(self, parent, i):
        if parent[i] == i:
            return i
        return self.find(parent, parent[i])

    # Union function (for disjoint set)
    def union(self, parent, rank, x, y):
        xroot = self.find(parent, x)
        yroot = self.find(parent, y)

        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1

    # Kruskal's Algorithm
    def kruskal_mst(self, departments):
        result = []  # store MST edges
        i, e = 0, 0  # i = index for sorted edges, e = count of edges in MST

        # Step 1: Sort edges by weight
        self.graph = sorted(self.graph, key=lambda item: item[2])

        parent = []
        rank = []

        # Create V subsets with single elements
        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        # Number of edges in MST = V-1
        while e < self.V - 1:
            # Step 2: Pick smallest edge
            u, v, w = self.graph[i]
            i = i + 1
            x = self.find(parent, u)
            y = self.find(parent, v)

            # If including edge doesn’t form a cycle, include it
            if x != y:
                e = e + 1
                result.append([u, v, w])
                self.union(parent, rank, x, y)

        # Print MST
        print("Minimum Spanning Tree (using Kruskal’s Algorithm):")
        total_cost = 0
        for u, v, weight in result:
            print(f"{departments[u]} -- {departments[v]} == {weight}")
            total_cost += weight
        print("Total Distance of MST:", total_cost)


# Example: Representing departments in a college
departments = [
    "Computer Dept", 
    "IT Dept", 
    "Mechanical Dept", 
    "Civil Dept", 
    "Electronics Dept"
]

g = Graph(len(departments))

# Adding edges (distances between departments)
g.add_edge(0, 1, 10)   # Computer - IT
g.add_edge(0, 2, 20)   # Computer - Mechanical
g.add_edge(1, 3, 25)   # IT - Civil
g.add_edge(2, 3, 30)   # Mechanical - Civil
g.add_edge(1, 4, 15)   # IT - Electronics
g.add_edge(3, 4, 35)   # Civil - Electronics
g.add_edge(2, 4, 40)   # Mechanical - Electronics

# Run Kruskal’s Algorithm
g.kruskal_mst(departments)


# Prims

# Graph Minimum Spanning Tree using Prim's Algorithm
# Departments of a college as nodes, distances as weighted edges

import sys

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]  # adjacency matrix

    # Add an undirected edge
    def add_edge(self, u, v, w):
        self.graph[u][v] = w
        self.graph[v][u] = w

    # Find vertex with minimum key value not yet included in MST
    def min_key(self, key, mst_set):
        min_val = sys.maxsize
        min_index = -1
        for v in range(self.V):
            if key[v] < min_val and not mst_set[v]:
                min_val = key[v]
                min_index = v
        return min_index

    # Prim's Algorithm
    def prim_mst(self, departments):
        key = [sys.maxsize] * self.V   # values used to pick minimum weight edge
        parent = [-1] * self.V         # store MST
        key[0] = 0                     # start from first vertex
        mst_set = [False] * self.V     # track included vertices

        for _ in range(self.V):
            u = self.min_key(key, mst_set)
            mst_set[u] = True

            for v in range(self.V):
                if self.graph[u][v] > 0 and not mst_set[v] and key[v] > self.graph[u][v]:
                    key[v] = self.graph[u][v]
                    parent[v] = u

        # Print MST
        print("Minimum Spanning Tree (using Prim’s Algorithm):")
        total_cost = 0
        for i in range(1, self.V):
            print(f"{departments[parent[i]]} -- {departments[i]} == {self.graph[i][parent[i]]}")
            total_cost += self.graph[i][parent[i]]
        print("Total Distance of MST:", total_cost)


# Example: Representing departments in a college
departments = [
    "Computer Dept", 
    "IT Dept", 
    "Mechanical Dept", 
    "Civil Dept", 
    "Electronics Dept"
]

g = Graph(len(departments))

# Adding edges (same distances as Kruskal example)
g.add_edge(0, 1, 10)   # Computer - IT
g.add_edge(0, 2, 20)   # Computer - Mechanical
g.add_edge(1, 3, 25)   # IT - Civil
g.add_edge(2, 3, 30)   # Mechanical - Civil
g.add_edge(1, 4, 15)   # IT - Electronics
g.add_edge(3, 4, 35)   # Civil - Electronics
g.add_edge(2, 4, 40)   # Mechanical - Electronics

# Run Prim’s Algorithm
g.prim_mst(departments)
    </code></pre>
</div>
              



<div class="snippet">
  <div class="title"><h1>7. Heap Sort</h1></div>
  <pre><code>
    def heapify (arr,n,i):
  largest = i
  left = 2*i+1
  right = 2*i+2
  
  if left<n and arr[left] > arr[largest]:
    largest = left
  if right < n and arr[right] > arr[largest]:
    largest = right
  if largest!=i:
    arr[largest],arr[i] = arr[i],arr[largest]
    heapify(arr,n,largest)
  
  
def heap_sort(arr):
  n = len(arr)
  for i in range(n//2-1,-1,-1):
    heapify(arr,n,i)
  for i in range (n-1,0,-1):
    arr[0],arr[i] = arr[i], arr[0]
    heapify(arr,i,0)

m = int(input("Enter no. of sorting values : "))
arr = []
print("Enter the values")
for i in range (m):
  n = int(input())
  arr.append(n)
print("Before Sorting : ",arr)
heap_sort(arr)
print("After Sorting : ",arr)

  </code></pre>
</div>

<div class="snippet">
  <div class="title"><h1>8. Merge Sort</h1></div>
  <pre><code>
    def merge_sort(orders):
    if len(orders) > 1:
        # Step 1: Divide
        mid = len(orders) // 2
        left_half = orders[:mid]
        right_half = orders[mid:]

        # Recursive calls to sort both halves
        merge_sort(left_half)
        merge_sort(right_half)

        # Step 2: Conquer (Merge the sorted halves)
        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] <= right_half[j]:
                orders[k] = left_half[i]
                i += 1
            else:
                orders[k] = right_half[j]
                j += 1
            k += 1

        # Copy remaining elements of left_half
        while i < len(left_half):
            orders[k] = left_half[i]
            i += 1
            k += 1

        # Copy remaining elements of right_half
        while j < len(right_half):
            orders[k] = right_half[j]
            j += 1
            k += 1


# ------------------- Main Program -------------------
if __name__ == "__main__":
    # Input: Online orders delivery times in minutes
    n = int(input("Enter number of online orders: "))
    delivery_times = []

    print("Enter delivery times (in minutes):")
    for _ in range(n):
        time = int(input())
        delivery_times.append(time)

    print("\nOriginal Delivery Times:", delivery_times)

    # Apply merge sort
    merge_sort(delivery_times)

    # Output: Sorted list
    print("Sorted Delivery Times (Quickest First):", delivery_times)
  </code></pre>
</div>

<div class="snippet">
  <div class="title"><h1>9. Knapsack</h1></div>
  <pre><code># Fractional Knapsack Problem - Maximize Profit by Shipping Partial Orders

def fractional_knapsack(weights, profits, capacity):
    n = len(weights)
    
    # Calculate profit/weight ratio
    ratio = [(profits[i] / weights[i], weights[i], profits[i]) for i in range(n)]
    
    # Sort by ratio in descending order
    ratio.sort(reverse=True)
    
    total_profit = 0.0
    remaining_capacity = capacity
    
    print("Parcel\tWeight\tProfit\tProfit/Weight")
    for r, w, p in ratio:
        print(f"{r:.2f}\t{w}\t{p}\t{r:.2f}")
    
    print("\nSelecting parcels for maximum profit...\n")
    
    for r, w, p in ratio:
        if remaining_capacity == 0:
            break
        if w <= remaining_capacity:
            # Take the full parcel
            total_profit += p
            remaining_capacity -= w
            print(f"Took full parcel (Weight={w}, Profit={p})")
        else:
            # Take fractional part
            fraction = remaining_capacity / w
            total_profit += p * fraction
            print(f"Took {fraction*100:.2f}% of parcel (Weight={w}, Profit={p})")
            remaining_capacity = 0
    
    print(f"\n Maximum Profit: {total_profit:.2f}")
    return total_profit


# Example usage:
weights = [10, 20, 30]
profits = [60, 100, 120]
capacity = 50

fractional_knapsack(weights, profits, capacity)
</code></pre>
</div>

<div class="snippet">
  <div class="title"><h1>10. Naive Algorithm</h1></div>
  <pre><code>
    def naive(text,pattern):
    n = len(text)
    m = len(pattern)
    indices = []
    for i in range(n-m+1):
        match = True
        for j in range(m):
            if text[i+j] != pattern[j]:
                match = False
        if match:
            indices.append(i)
    return indices

text = input("Enter a text : ")
pattern = input("Enter a pattern : ")

result = naive(text,pattern)

if result:
    print("match is found at indices",result)
else:
    print("Not found")
  </code></pre>
</div>

</body>
</html>

